---
layout:     post
title:      Python-协程
subtitle:   
date:       2018-07-17
author:     Mehaei
header-img: img/post-bg-ioses.jpg
catalog: true
tags:
    - python
---
**协程**　　又称微线程，纤程。　　它是比线程更小的执行单元，因为它自带CPU上下文。这样只要在合适的时机，我们可以把一个协程切换到另一个协程当中。　　只要这个过程保存或恢复CPU上下文，那么程序就可以运行。　　通俗的理解：在一个线程中的某个函数，可以在任何地方保存当前函数的一些临时变量等信息，然后切换到另外一个函数中执行，　　（注意不是通过调用函数的方式来实现），并且切换的次数以及什么时候再切换到原来的函数由开发者确定。

　　**协程和线程一样共享堆，不共享栈，协程由程序员在协程的代码里显示调度。**

### 协程和线程有什么不同

　　那么这个过程看起来和线程差不多。其实不然, 线程切换从系统层面远不止保存和恢复 CPU上下文这么简单。 操作系统为了程序运行的高效性每个线程都有自己缓存Cache等等数据，操作系统还会帮你做这些数据的恢复操作。 所以线程的切换非常耗性能。但是协程的切换只是单纯的操作CPU的上下文，所以一秒钟切换个上百万次系统都抗的住。

**协程的优缺点：**

**优势：**

　　1.协程极高的执行效率。因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显。

　　2.就是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。

　　3.把一个IO操作 写成一个协程。当触发IO操作的时候就自动让出CPU给其他协程。要知道协程的切换很轻的。 协程通过这种对异步IO的封装 既保留了性能也保证了代码的容易编写和可读性

**缺点：**

　　1.在IO密集型的程序中由于IO操作远远慢于CPU的操作，所以往往需要CPU去等IO操作。 同步IO下系统需要切换线程，让操作系统可以在IO过程中执行其他的东西。 这样虽然代码是符合人类的思维习惯但是由于大量的线程切换带来了大量的性能的浪费，尤其是IO密集型的程序。

　　2.所以人们发明了异步IO。就是当数据到达的时候触发我的回调。来减少线程切换带来性能损失。 但是这样的坏处也是很大的，主要的坏处就是操作被 分片 了，代码写的不是 一气呵成 这种。 而是每次来段数据就要判断 数据够不够处理哇，够处理就处理吧，不够处理就在等等吧。这样代码的可读性很低，其实也不符合人类的习惯。

　　3..协程在高IO密集型的程序下很好。但是高CPU密集型的程序下没啥好处。

### 协程带来的问题

　　协程有一个问题，就是系统并不感知，所以操作系统不会帮你做切换。 那么谁来帮你做切换？让需要执行的协程更多的获得CPU时间才是问题的关键。　　举个例子如下：

　　　目前的协程框架一般都是设计成 1:N 模式。所谓 1:N 就是一个线程作为一个容器里面放置多个协程。 那么谁来适时的切换这些协程？答案是有协程自己主动让出CPU，也就是每个协程池里面有一个调度器， 这个调度器是被动调度的。意思就是他不会主动调度。而且当一个协程发现自己执行不下去了(比如异步等待网络的数据回来，但是当前还没有数据到)， 这个时候就可以由这个协程通知调度器，这个时候执行到调度器的代码，调度器根据事先设计好的调度算法找到当前最需要CPU的协程。 切换这个协程的CPU上下文把CPU的运行权交个这个协程，直到这个协程出现执行不下去需要等等的情况，或者它调用主动让出CPU的API之类，触发下一次调度。

了解这个例子前需要了解生成器  https://www.cnblogs.com/mswyf/p/9283386.html

### yield实现一个简单的协程

```
import time
def A():
    while True:
        print('----------a----------')
        yield
        time.sleep(1)
def  B(a):
    while True:
        print('------------b-----------')
        next(a)
        time.sleep(1)
if __name__ == '__main__':
    a = A()
    B(a)
```

结果为：

```
------------b-----------
----------a----------
------------b-----------
----------a----------
------------b-----------
----------a----------
------------b-----------
----------a----------
------------b-----------
----------a----------
------------b-----------
```

这样就实现了一个简单的协程

### 使用greenlet实现协程

```
from greenlet import greenlet
import time
def Fool():
    while True:
        print('--------a---------')
        #切换到fool2
        g2.switch()
        time.sleep(1)
 
def Fool2():
    while True:
        print('---------b--------')
        #切换到Fool
        g1.switch()
        time.sleep(1)
#创建协程任务
g1 = greenlet(Fool)
g2 = greenlet(Fool2)
 
#调用任务
g1.switch()
```

结果为：

```
------------b-----------
----------a----------
------------b-----------
----------a----------
------------b-----------
----------a----------
------------b-----------
----------a----------
------------b--------
```

### 使用gevent实现协程

原理：其原理是当一个greenlet遇到IO(指的是input output 输入输出，比如网络、文件操作等)操作时，比如访问网络，就自动切换到其他的greenlet，等到IO操作完成，再在适当的时候切换回来继续执行。

由于IO操作非常耗时，经常使程序处于等待状态，有了gevent为我们自动切换协程，就保证总有greenlet在运行，而不是等待I

```
import gevent
def task1(n):
    for i in range(n):
        print('----task1-----')
        gevent.sleep(1)
        # time.sleep(1) # time.sleep没有让gevent感知到等待
def task2(n):
    for i in range(n):
        print('----task2-----')
        gevent.sleep(1)
        # time.sleep(1)
def main():
    g1 = gevent.spawn(task1, 5)
    g2 = gevent.spawn(task2, 5)
    # 等待所有携程任务运行完毕
    gevent.joinall([g1, g2])
    print("运行结束")
 
if __name__ == "__main__":
    main()
```

结果为：

```
----task1-----
----task2-----
----task1-----
----task2-----
----task1-----
----task2-----
----task1-----
----task2-----
----task1-----
----task2-----
运行结束
```
