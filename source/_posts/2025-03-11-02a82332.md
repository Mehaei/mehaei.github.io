---
layout:     post
title:      "Python解析multipart boundary：aiohttp与requests文件上传详解"
subtitle:   
date:       2025-03-11
author:     胖胖很瘦
thumbnail:  /images/02a82332/thumbnail.png
catalog: true
categories: python模块集合
original_url: https://mp.weixin.qq.com/s/PLkCYQuicE5ZZNAZ0Gj5gw
tags:
    - python模块集合
---

## 简介

在Web开发中，处理文件上传或复杂表单数据时，经常需要使用`multipart/form-data`格式，而其中的**boundary**参数则是区分各部分数据的重要分隔符。本文将深入介绍boundary的概念，并针对Python中两个常用的HTTP请求库——**aiohttp**和**requests**，分别展示自动与手动构建boundary的方式。最后，通过详细的对比，帮助你理解各自的优缺点，从而选择适合的解决方案。

---

## 目录

1. 什么是boundary?
2. requests库中boundary的处理

* 2.1 自动处理boundary
* 2.2 手动设置 boundary
* 2.3 手动构建boundary

3. aiohttp库中boundary的处理

* 3.1 自动处理boundary
* 3.2 手动设置 boundary
* 3.3 手动构建boundary

4. aiohttp与requests的优缺点对比
5. 总结
6. 相关阅读

---

## 1. 什么是boundary？

在HTTP协议中，当我们使用`multipart/form-data`提交表单时，整个请求体包含多个部分，每部分之间的边界由一个称为**boundary**的字符串分隔。例如，HTTP请求头中可能包含如下内容：

```
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary7MA4YWxkTrZu0gW
```

这个boundary字符串保证服务器能够正确解析各个字段和文件内容，是构造复杂表单数据的重要组成部分。

---

## 2. requests库中boundary的处理

### 2.1 自动处理boundary

使用requests发送表单数据时，只需要将文件或字段通过`files`和`data`参数传递，requests会自动生成boundary并封装数据。

```
import requests  
  
# 目标URL（测试用：httpbin.org可返回提交的数据）  
url = 'http://httpbin.org/post'  
  
# 构造文件上传数据：requests会自动构造multipart/form-data请求  
files = {  
    # 第一个参数为字段名称，元组中依次为：(文件名, 文件对象, MIME类型)  
    'file':('test.txt', open('test.txt', 'rb'), 'text/plain')  
}  
  
# 发送POST请求  
response = requests.post(url, files=files)  
  
# 打印服务器返回内容  
print(response.text)
```

注释说明：

* 此示例中，requests自动在请求头中生成`Content-Type`及其中的boundary，无需开发者手动干预。
* 适用于大部分常规使用场景。

---

### 2.2 手动设置 Boundary

在某些特殊情况下，可能需要手动指定 boundary。此时可以借助 requests-toolbelt 库中的 `MultipartEncoder`。

首先需安装 requests-toolbelt：

```
pip install requests-toolbelt
```

下面是手动指定 boundary 的示例代码：

```
from requests_toolbelt.multipart.encoder import MultipartEncoder  
import requests  
  
def send_formdata_manual():  
    url = 'http://httpbin.org/post'  
    # 自定义 boundary 字符串  
    boundary = '----WebKitFormBoundary7MA4YWxkTrZu0gW'  
    # 使用 MultipartEncoder 构造 multipart 数据，同时指定 boundary  
    encoder = MultipartEncoder(  
        fields={  
            'field1': 'value1',  
            'file': ('test.txt', open('test.txt', 'rb'), 'text/plain')  
        },  
        boundary=boundary  
    )  
    # 设置 Content-Type 头，包含自定义的 boundary  
    headers = {'Content-Type': encoder.content_type}  
    # 发送 POST 请求  
    response = requests.post(url, data=encoder, headers=headers)  
    print("手动设置 boundary 的响应：", response.text)  
  
send_formdata_manual()
```

### 2.3 手动构建boundary

有时我们需要对请求体的格式进行更精细的控制，此时可以选择手动构建multipart/form-data格式的数据。

```
import requests  
  
# 目标URL  
url = 'http://httpbin.org/post'  
  
# 自定义boundary字符串  
boundary = '----WebKitFormBoundary7MA4YWxkTrZu0gW'  
  
# 构造请求体各部分数据，注意各部分之间以boundary分隔  
data_lines = []  
# 添加第一个字段：普通文本字段  
data_lines.append('--' + boundary)  
data_lines.append('Content-Disposition: form-data; name="field1"')  
data_lines.append('')  # 空行分隔头与内容  
data_lines.append('value1')  
  
# 添加第二个字段：文件字段  
data_lines.append('--' + boundary)  
data_lines.append('Content-Disposition: form-data; name="file"; filename="test.txt"')  
data_lines.append('Content-Type: text/plain')  
data_lines.append('')  
# 读取文件内容（确保当前目录下有test.txt文件）  
with open('test.txt', 'r', encoding='utf-8') as f:  
    data_lines.append(f.read())  
  
# 结束标志：加上结尾的boundary标记  
data_lines.append('--' + boundary + '--')  
  
# 将各部分用CRLF连接  
body = '\r\n'.join(data_lines)  
  
# 构造请求头，指明Content-Type及boundary  
headers = {  
    'Content-Type': 'multipart/form-data; boundary=' + boundary  
}  
  
# 发送POST请求，此处需要将body转换为字节串  
response = requests.post(url, data=body.encode('utf-8'), headers=headers)  
print(response.text)
```

注释说明：

* 手动构造的流程：先定义好boundary，再将每个部分的数据按照标准格式拼接（包括Content-Disposition和Content-Type等）。
* 最后将拼接好的字符串通过`encode('utf-8')`转为字节发送。

---

![](/images/02a82332/1.png)

## 3. aiohttp库中boundary的处理

### 3.1 自动处理boundary

aiohttp作为异步HTTP库，同样支持通过`aiohttp.FormData`构造multipart/form-data数据，并自动管理boundary。

```
import aiohttp  
import asyncio  
  
async def main():  
    url = 'http://httpbin.org/post'  
    # 使用aiohttp提供的FormData构造表单数据  
    form = aiohttp.FormData()  
    form.add_field('field1', 'value1')  
    # 添加文件字段，注意以二进制方式打开文件  
    form.add_field('file',  
                   open('test.txt', 'rb'),  
                   filename='test.txt',  
                   content_type='text/plain')  
      
    # 使用异步上下文管理器发送请求  
    async with aiohttp.ClientSession() as session:  
        async with session.post(url, data=form) as resp:  
            print(await resp.text())  
  
# 运行异步任务  
asyncio.run(main())
```

注释说明：

* `aiohttp.FormData`会自动生成适合的boundary，并构造请求体。
* 异步写法适合高并发或异步应用场景。

---

### 3.2 手动设置 Boundary

有时需要自定义 boundary，比如为了和服务端进行特殊交互，此时可以使用 `aiohttp.MultipartWriter` 手动构造 multipart 数据。

```
import aiohttp  
import asyncio  
  
async def send_formdata_manual():  
    # 自定义 boundary 字符串（注意确保不会与数据内容冲突）  
    boundary = '----WebKitFormBoundary7MA4YWxkTrZu0gW'  
    # 创建 MultipartWriter 对象，手动指定 boundary  
    mp_writer = aiohttp.MultipartWriter(boundary=boundary)  
      
    # 添加普通字段  
    part1 = mp_writer.append('value1')  
    part1.set_content_disposition('form-data', name='field1')  
      
    # 添加文件字段  
    with open('test.txt', 'rb') as f:  
        part2 = mp_writer.append(f.read(), {'Content-Type': 'text/plain'})  
        part2.set_content_disposition('form-data', name='file', filename='test.txt')  
      
    # 发送 POST 请求  
    async with aiohttp.ClientSession() as session:  
        async with session.post('http://httpbin.org/post', data=mp_writer) as resp:  
            result = await resp.text()  
            print("手动设置 boundary 的响应：", result)  
  
# 运行异步任务  
asyncio.run(send_formdata_manual())
```

代码说明：

* 使用 `aiohttp.MultipartWriter` 手动构造 multipart 数据，并通过参数 `boundary` 指定自定义分隔符。
* 每个字段使用 `append` 方法添加，并通过 `set_content_disposition` 设置字段名称与文件信息。
* 通过 aiohttp 异步发送请求，观察服务端对自定义 boundary 的处理结果。

---

### 3.3 手动构建boundary

与requests类似，aiohttp也支持手动构造请求体，适用于需要完全自定义请求体格式的场景。

```
import aiohttp  
import asyncio  
  
async def main():  
    url = 'http://httpbin.org/post'  
      
    # 自定义boundary  
    boundary = '----WebKitFormBoundary7MA4YWxkTrZu0gW'  
    parts = []  
    # 添加普通文本字段  
    parts.append('--' + boundary)  
    parts.append('Content-Disposition: form-data; name="field1"')  
    parts.append('')  
    parts.append('value1')  
      
    # 添加文件字段  
    parts.append('--' + boundary)  
    parts.append('Content-Disposition: form-data; name="file"; filename="test.txt"')  
    parts.append('Content-Type: text/plain')  
    parts.append('')  
    with open('test.txt', 'r', encoding='utf-8') as f:  
        parts.append(f.read())  
      
    # 结束标记  
    parts.append('--' + boundary + '--')  
      
    # 构造完整请求体  
    body = '\r\n'.join(parts)  
    headers = {  
        'Content-Type': 'multipart/form-data; boundary=' + boundary  
    }  
      
    async with aiohttp.ClientSession() as session:  
        async with session.post(url, data=body.encode('utf-8'), headers=headers) as resp:  
            print(await resp.text())  
  
asyncio.run(main())
```

注释说明：

* 手动构造流程与requests类似，需自行拼接各部分数据和boundary。
* 注意在异步环境中，通过`await`获取响应数据。

---

## 4. aiohttp与requests的优缺点对比

| 特性 | requests | aiohttp |
| --- | --- | --- |
| **同步/异步** | 同步，适合简单脚本及同步流程 | 异步，适合高并发、大规模请求场景 |
| **易用性** | API设计直观、简单易用，自动处理multipart表单数据 | API设计灵活，适合异步编程，但学习曲线稍陡 |
| **性能** | 在低并发场景下表现良好，但阻塞I/O可能导致性能瓶颈 | 利用异步机制高效处理并发请求，性能优势明显 |
| **手动构造支持** | 允许手动构造请求体，适用于对请求数据精细控制的需求 | 同样支持手动构造，但通常建议使用内置FormData自动处理 |
| **社区与文档** | 社区成熟，文档详细，示例丰富 | 社区活跃，文档逐步完善，但部分高级用法可能需要参考源码 |

注释说明：

* 如果项目对并发和性能有较高要求，aiohttp无疑是更好的选择；
* 对于多数普通应用，requests的简单易用更能提高开发效率。

---

## 5. 总结

本文详细介绍了multipart/form-data中boundary的作用，并对Python中requests与aiohttp两种HTTP请求库在处理boundary时的自动与手动构造方式进行了深入解析。通过完整的代码示例，你可以看到两者在实际应用中的实现细节及各自的优缺点。无论是同步的requests还是异步的aiohttp，都能满足大部分场景的需求，而如何选择则应基于具体项目需求和性能要求。

---

## 6. 相关阅读

* [使用aiohttp和requests发送表单数据，携带文件和字段](https://mp.weixin.qq.com/s?__biz=MzUyMzk3OTYyMQ==&mid=2247488497&idx=1&sn=37cabe64807b2e7cb82a43547d4ebfcb&scene=21#wechat_redirect "使用aiohttp和requests发送表单数据，携带文件和字段")
* [Python glob 模块全解析：轻松处理文件路径匹配](https://mp.weixin.qq.com/s?__biz=MzUyMzk3OTYyMQ==&mid=2247488640&idx=1&sn=439f43d2c8c571a2adcbd4b86d65cbfd&scene=21#wechat_redirect "Python glob 模块全解析：轻松处理文件路径匹配")
* [极致优化：Python 实战教你高效转换 FITS 图像并精确标注坐标](https://mp.weixin.qq.com/s?__biz=MzUyMzk3OTYyMQ==&mid=2247488635&idx=1&sn=e02ab9d107f0811008b7c87293d7ce77&scene=21#wechat_redirect "极致优化：Python 实战教你高效转换 FITS 图像并精确标注坐标")
* [数据可视化利器：Pyecharts在Mac和Jupyter中的安装与常见问题（附世界地图映射表）](https://mp.weixin.qq.com/s?__biz=MzUyMzk3OTYyMQ==&mid=2247488620&idx=1&sn=a41d1d35440391f51bba4ae2e1a9b580&scene=21#wechat_redirect "数据可视化利器：Pyecharts在Mac和Jupyter中的安装与常见问题（附世界地图映射表）")